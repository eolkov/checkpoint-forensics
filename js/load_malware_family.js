/**
 * This class is responsible for building the Malware Family section in the report.
 * This section includes on the right side the family's name and description as well as similarity attributes 
 * between the emulated file and the malware family and on the left side a map (with a graph at its bottom) 
 * describing the spread of the malware family in time.
 * When the map is played it's according to the time of the ticks in the graph x axis.
 * The data showed for a specific tick in the map and graph is aggregated for all the dates between
 * the date of the current tick and the date of the next tick.
 * The y value of the graph is number of hits (attacks) for the specific date period corresponding to 
 * the current tick.

 * this.setData() should be called when the report is being loaded and when the data of the malware family is 
 * needed to be updated from Cloud. It sets only the data of the malware family itself (name, description and map data).
 * this.setSimilaritiesData() is called when the report is being loaded. It sets the data related to the similarities
 * between the emulated file and the malware family (the match percentage and similarity types, i.e. iocs, strings, 
 * hashes, communication).
 *   
 * this.dataPerTick is the data strcuture into which the data of the attacks is
 * written from the input json. Then is used to build the graph and building this.circles dynamically
 * during the map play.
 */
function MalwareFamily() {

  const MAP_EVENTS_COLOR = 'rgb(255, 77, 77)';
/**
 * Resets data related to circles.
 */
  this.resetCircles = () => {
    /* The data is viewed in map according to this array.
      The data in this array is dynamic - it's being updated during map + graph play.
      Each circle (array object) corresponds to a circle on the map  */
    this.circles = [];
    /* Maps feature id of map circle to a circle of this class (circles contained in this.circles) */
    this.featureIdToCircle = {};
  }

  /**
   * Resets data.
   * Should be done before new data is load, either when report is opened or when
   * new data from Cloud is loaded
   */
  this.resetData = () => {
    // Contains the map data from the input json
    this.dataPerTick = [];
    // Counts total attacks, accross the whole time period the map covers
    this.totalHitsForAllDates = 0;
    // Time elapsed between x axis ticks (for playing)
    this.intervalBetweenTicks = 2000; // milliseconds
    // Indicates whether the graph is hidden is currently hidden
    this.hiddenGraph = false;
    // Indicates whether map + graph are now played
    this.played = false;
    /* During map + graph play it contains the id of the timer for playing the next tick (next
      date) in the map. Used to disable the timer in case of pause */
    this.nextDateTimerID = -1;
    /* Array containing the listener keys for the animated circles.
      Used in order to disable listeners in case replay button was clicked */
    this.animationListenerKeys = [];
    /* This features counter is used to create a unique id for features on the map. 
      The counter is zeroed when play starts from the beginning.
      (It's not used for the features of the basic empty map, only for the circles
      on the map) */
    this.featureIdCounter = 0;
    /* map_time DOM object used as timer for graph + map play. During play it begins in 0 and
      finishes in 1 */
    $("#map_time").attr("T",0);
    
    this.resetCircles();
    
    this.primaryFamilyName = "";
  }
  
  /**
   * Adds the data of attack events related to the x axis tick with index currTickIdx 
   * to this.dataPerTick.
   * 
   * @param {array} events Attack events
   * @param {int} currTickIdx index of the time tick relevant to events
   */
  this.addEventsToTickIdx = (events, currTickIdx) => {
    var tickObj = this.dataPerTick[currTickIdx];
    for(var i=0; i<events.length; ++i) {
      var currEvent = events[i];
      var wasFound = false;
      /* First there's a check of whether there's already an existing object for the tick
        with the same coordinates of the event */
      for(var j=0; j< tickObj.coords.length; ++j) {
        if((currEvent.longitude == tickObj.coords[j].longitude) &&
          (currEvent.latitude == tickObj.coords[j].latitude)) {
            // Object found and updated
            tickObj.coords[j].hits += currEvent.hits;
            wasFound = true;
          }
      }
      if(!wasFound) {
        // Creates object with the same coordinates of the event
        tickObj.coords.push({
          longitude: currEvent.longitude,
          latitude: currEvent.latitude,
          country: currEvent.country,
          hits: currEvent.hits
        });
      }
    }
  }

  /**
   * Given json data of attacks, it adds this.dataPerTick an object per tick (bottom graph tick).
   * Each object in this.dataPerTick represent the events of relevant to the tick time object.date.
   * Also, each such object has an array with the coodinates of all attacks that happened in the
   * range of the time tick.
   */
  this.jsonToDisplayedDataPerTick = (mapData) => {

    if(Object.keys(mapData).length == 0) {
        return;
    }
    // Initializing the data structure that is filled
    this.dataPerTick = [];

    const milliSecondsInDay = 1000 * 60 * 60 * 24;

    // Creating and sorting array of strings representing dates of attacks
    var datesArr = Object.keys(mapData);
    datesArr.sort(function(d1, d2) {
      return (new Date(d1)).getTime() - (new Date(d2)).getTime();
    });
    // Calculating the number of days there is data for
    var totalDaysInMs = ((new Date(datesArr[datesArr.length - 1])).getTime() - 
                        (new Date(datesArr[0])).getTime());
    var totalDays = Math.floor(totalDaysInMs / milliSecondsInDay) + 1;

    // Calculate number of days in tick
    const maxNumOfDaysOnScale = 8;
    this.numOfDaysInTick = 1;
    if(totalDays > maxNumOfDaysOnScale) {
      this.numOfDaysInTick  = Math.ceil(totalDays / maxNumOfDaysOnScale);
    }
    // Calculating the number of x value ticks
    var numOfTicks = Math.ceil((totalDays + 1) / this.numOfDaysInTick);

    // Preparing the tick objects
    for(var i=0; i<numOfTicks; ++i) {
      var tickDate = new Date((new Date(datesArr[0])).getTime() + i * this.numOfDaysInTick * milliSecondsInDay);
      this.dataPerTick[i] = {
        date: tickDate,
        coords: []
      };
    }
    // Adding the events to the appropriate tick objects
    var currTickIdx = 0;
    var currTick = this.dataPerTick[0].date;
    for(var i=0; i<datesArr.length; ++i) {
      // Finding the relevant tick for the events that occured in date datesArr[i]
      while((new Date(datesArr[i])).getTime() >= currTick.getTime() + (this.numOfDaysInTick * milliSecondsInDay)) {
        currTick = this.dataPerTick[++currTickIdx].date;
      }
      // Adds to this.dataPerTick data for currTick date
      this.addEventsToTickIdx(mapData[datesArr[i]], currTickIdx);
    }
  }

  /**
   * Takes the data per date datastructure and returns a datastructure that
   * is used to build the map's graph 
   */
  this.toGraphData = (dataPerTick) => {
    if(dataPerTick.length == 0) {
      return dataPerTick;
    }
    // Adds to datastructure another data object with zero coordinates, in order for graph to start from zero
    var zeroDate = new Date (dataPerTick[0].date.getTime() - 5*this.numOfDaysInTick*60*60*1000);
    var graphData =  dataPerTick.slice(0); // In order to copy the datastructure
    graphData.unshift({
      date: zeroDate,
      coords: []
    });
    return graphData;
  }

  /**
   * Transformation function used to move the red line to the y position corresponding to
   * the current play time.
   */
  this.translateMovingLine = (path) => {
    // Calculating time played and time left to play
    var alreadyPlayed = path.getTotalLength() * $('#map_time').attr('T'); //To get the length played before last pause
    var leftToPlay = path.getTotalLength() - alreadyPlayed; // Left to played to the end from last play
    return (d, i, a) => {
      return (t) => {
       var atLength = alreadyPlayed + t  * leftToPlay;
        // Get position of current point on graph
        var p = path.getPointAtLength(atLength);
        /* Changing the value next to the red line to be the matching value on the y axis
         and moving it to be in the same position of the line */
        this.movingVal.text(Math.floor(this.yScale.invert(p.y)));
        this.movingVal.attr("transform", "translate(0," + ((-1)*(this.yAxisHeight - p.y)) + ")");
        return "translate(0," + ((-1)*(this.yAxisHeight - p.y)) + ")";  // Moving the red line to the current time y position
      }
    }
  }

  /**
   * Building the graph under the map
   */
  this.buildGraph = () => {
    /* graphData is the same datastructure as this.dataPerData, with small addition of "zero tail"
     in the beginning of the graph */
    var graphData = this.toGraphData(this.dataPerTick);
    var graphHeight = parseInt($('#map_graph').css('height'));
    var graphWidth = parseInt($('#map_graph').css('width'));
    var svgHeight = graphHeight, svgWidth = graphWidth;
    var margin = { top: 20, right: 30, bottom: 40, left: 50 };
    var width = svgWidth - margin.left - margin.right;
    var height = svgHeight - margin.top - margin.bottom;
    this.xAxisLength = width - 10;
    this.yAxisHeight = height;

    var svg = d3.select('#map_graph svg')
      .attr("width", svgWidth)
      .attr("height", svgHeight)
      .style("display", "block")
      .style("margin", 0)
      .append("g").attr("transform", 
      "translate(" + margin.left + "," + margin.top + ")");

    // Setting the data of the graph
    svg.datum(graphData);

    // Clipping out anything that may cross the limit of the axises
    svg.append("clipPath")
      .attr("id", "clip")
      .append("rect")
      .attr("width", width)
      .attr("height", height);

    // Building x axis  
    this.xScale = d3.time.scale()
      .domain(d3.extent(graphData, function(d) {
        // The values of x axis are the relevant dates
        return d.date;
      })).range([0, this.xAxisLength]);

    var xAxis = d3.svg.axis()
      .scale(this.xScale)
      .orient("bottom")
      .tickFormat(d3.time.format("%d/%m"))
      .tickValues(graphData.map(function(d) { return d.date }))
      .tickSize(8)
      .tickPadding(15)
      .outerTickSize(0);

    svg.append("g")
      
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")") // x axis is in the bottom part of the graph
      .call(xAxis);

    // Building y axis

    // Function that counts the hits accross all coordinates for a specific date
    var calcHitsPerDate = function(d) {
      var totalHitsPerDate = 0;
      for(var i=0; i<d.coords.length; ++i) {
        totalHitsPerDate += d.coords[i].hits;
      }
      return totalHitsPerDate; 
    };

    // Preparing the array containing the Y ticks that should be shown in graph
    const maxNumYTicks = 4; // Not more than this number of ticks will be shown on Y axis (besides the zero)
    
    var yTickValues = [0]; // Initializing with the zero tick
    var maxGraphValue = d3.max(graphData, d => calcHitsPerDate(d));
    var intervalBetweenYTicks;
    var numOfYTicks;
    if(maxGraphValue < maxNumYTicks) {
      intervalBetweenYTicks = 1;
      numOfYTicks = maxGraphValue;
    }
    else {
      numOfYTicks = maxNumYTicks;
      intervalBetweenYTicks = Math.floor(maxGraphValue / maxNumYTicks);
    }
    var currYTick = intervalBetweenYTicks;
    for(var i=0; i<numOfYTicks; ++i) {
      yTickValues.push(currYTick);
      currYTick += intervalBetweenYTicks;
    }

    this.yScale = d3.scale.linear()
      .domain(d3.extent(graphData, calcHitsPerDate)) // The y value is sum of all the hits for a specific date period
      .range([this.yAxisHeight, 0]);

    var yAxis = d3.svg.axis()
      .scale(this.yScale)
      .tickValues(yTickValues)
      .tickFormat(d3.format("d"))
      .orient("left");

    svg.append("g")
      .attr("class", "y axis collapsible")
      .call(yAxis);

    // Adding the area under the graph (the area itself is a gradient) 

    var area = d3.svg.area()
      .interpolate("monotone")
      .x((d) => { return this.xScale(d.date); })
      .y0(height)
      .y1((d) => { return this.yScale(calcHitsPerDate(d)); });

    svg.append("path")
      .attr("class", "area collapsible")
      .style("fill", "url(#grad3)")
      .attr("clip-path", "url(#clip)")
      .attr("d", area);

    // Adding the graph line

    var graphLine = d3.svg.line()
      .interpolate("monotone")
      .x((d) => { return this.xScale(d.date); })
      .y((d) => { return this.yScale(calcHitsPerDate(d)); });

    this.graphPath = svg.append("path")
      .attr("class", "line collapsible")
      .style("stroke", MAP_EVENTS_COLOR)
      .style('stroke-opacity', 0.5)
      .attr("clip-path", "url(#clip)")
      .attr("d", graphLine);


    // Adding a horizontal dotted line for each one of the Y ticks
    const graphConstantLinesColor =  'rgba(255,255,255,1)';

    for(var i=1; i<yTickValues.length; ++i) {
      var currLine = d3.svg.line()
      .interpolate('linear')
      .x((d) => { return this.xScale(d.date); })
      .y((d) => { return this.yScale(yTickValues[i]); });

      svg.append('path')
      .attr('class', 'line collapsible')
      .style('stroke', graphConstantLinesColor)
      .style('fill', graphConstantLinesColor)
      .style('stroke-width', 0.2)
      .style('stroke-dasharray', 1)
      .attr('d', currLine);
    }
   

    // Adding the slider. Its position on the x axis is corresponding to the current played tick (date range)
    this.slider = svg.append('g');
    const niddleBaseRadius = 5.5;
    const sliderColor = '#E0E4E8'

    this.slider.append('circle')
                .attr('cx', 0)
                .attr('cy', height)
                .attr('r', niddleBaseRadius)
                .attr('fill', sliderColor);

    this.slider.append('line')
      .attr('x1', 0)
      .attr('y1', 0)
      .attr('x2', 0)
      .attr('y2', height)
      .attr('stroke-width', 0.45)
      .attr('stroke', sliderColor)
      .attr('class', 'collapsible');
      
    // Click on the play/pause button
    $('#map_controls > a:first-child').on('click', (event) => {
      event.preventDefault();
      if(!this.played) {
        this.playMapAndGraph();
      }
      else {
        this.pause();
      }
    });
    // Click on the replay button
    $('#map_controls > a:nth-child(2)').on('click', (event) => {
      event.preventDefault();
      this.replayMapAndGraph();
    }) ;
    // To release button after mouse press is over
    $('#map_controls .btn-circle').on('mouseup', function(){
      $(this).blur();
    });
  }


  this.calculateTotalHitsForAllDates = () => {
    var totalHits = 0;
    for(var i=0; i<this.dataPerTick.length; ++i) {
      for(var j=0; j<this.dataPerTick[i].coords.length; ++j) {
        totalHits += this.dataPerTick[i].coords[j].hits;
      }
    }
    return totalHits;
  }
  
  this.createMapLayers = () => {
    // Creating the source vector and vector layer for the map background (the continents)
    this.basicMapSourceVec =   new ol.source.Vector({
                                          format: new ol.format.GeoJSON(),
                                          features: (new ol.format.GeoJSON()).readFeatures(getCountriesGeoJSON()),
                                          wrapX: false
                                  });
    this.basicMapVecLayer = new ol.layer.Vector({
                                  source: this.basicMapSourceVec,
                                  style: (function(feature) { return style; })
                                  });
  
    var style = new ol.style.Style({
      fill: new ol.style.Fill({
        color: 'rgba(188, 227, 254, 0.2)'
      }),
      stroke: new ol.style.Stroke({
        color: 'transparent'
      }),
      text: new ol.style.Text({
        font: '12px Calibri,sans-serif',
        fill: new ol.style.Fill({
          color: '#000'
        }),
        stroke: new ol.style.Stroke({
          color: '#fff',
          width: 3
        })
      })
    });
  
    this.map = new ol.Map({
                                  target: 'map',
                                  layers: [this.basicMapVecLayer],
                                  controls: ol.control.defaults({
                                      attributionOptions: {
                                        collapsible: false
                                      },
                                      zoom: false
                                  }),
                                  view: new ol.View({
                                      center: [0, 0],
                                      zoom: 1.4,
                                      projection: "EPSG:4326"
                                  }),
                                  interactions: ol.interaction.defaults({
                                    doubleClickZoom: false,
                                    dragAndDrop: false,
                                    dragPan: false,
                                    keyboardPan: false,
                                    keyboardZoom: false,
                                    mouseWheelZoom: false,
                                    pointer: false,
                                    select: false
                                  }),
                                });

    /* Creating the source vector and vector layer for the fixed size circles 
       (i.e. the points within the bigger circles) */                          
    this.fixedPointsSourceVec = new ol.source.Vector({
                                  wrapX: false
                                });
                                
    this.fixedPointsVecLayer = new ol.layer.Vector({
                                    source: this.fixedPointsSourceVec,
                                    map: this.map
                                  });

                                  
    /* Creating the source vector and vector layer for the circles that are 
      during animation */
    this.animatedCirclesSourceVec = new ol.source.Vector({
                                  wrapX: false
                                });
     
    this.animatedCirclesVecLayer = new ol.layer.Vector({
                                    source: this.animatedCirclesSourceVec,
                                    map: this.map
                                  });

    /* Creating the source vector and vector layer for the fixed big circles
      (appear after animations of animated circles have finished) */
    this.permanentCirclesSourceVec = new ol.source.Vector({
                                    wrapX: false
                                  });
    this.permanentCirclesVecLayer = new ol.layer.Vector({
                                    source: this.permanentCirclesSourceVec,
                                    map: this.map,
                                  });


    this.animatedCirclesSourceVec.on('addfeature', (e) => {
      this.flash(e.feature);
    });

    var overlay = new ol.Overlay({
      element: $("#point_info").get(0),
      positioning: 'bottom-left'
    });
    overlay.setMap(this.map);
    this.map.on(['pointermove', 'singleclick'], (event) => {
      var feature = this.map.forEachFeatureAtPixel(event.pixel, (feature) => {
        if(feature.getGeometry().getType() == 'Circle') {
          overlay.setPosition(event.coordinate);
          overlay.getElement().innerHTML = feature.country;
          return feature;
        }
      });
      overlay.getElement().style.display = feature ? '' : 'none';
    });
  }

  this.drawAttackCircles = () => {
    for(var i=0; i<this.circles.length; ++i) {
      var currCircle = this.circles[i]; 
      if(currCircle.shouldDraw) {
        var geom = new ol.geom.Circle(ol.proj.fromLonLat([currCircle.x, currCircle.y], "EPSG:4326"), 2);
        var styleTrans = new ol.style.Style({
          stroke: new ol.style.Stroke({
            color: 'transparent'
          })
        });
        var style = new ol.style.Style({
          fill: new ol.style.Fill({
            color: MAP_EVENTS_COLOR
          }),
        });
        
        var fixedGeom = new ol.geom.Circle(ol.proj.fromLonLat([currCircle.x, currCircle.y], "EPSG:4326"), 1.2);
        var fixedFeature = new ol.Feature(fixedGeom);
        fixedFeature.setStyle(style);
        this.fixedPointsSourceVec.addFeature(fixedFeature);

        var feature = new ol.Feature(geom);
        feature.setStyle(styleTrans);
        feature.setId(++this.featureIdCounter);
        this.featureIdToCircle[feature.getId()] = currCircle;
        feature.country = currCircle.country;
        this.animatedCirclesSourceVec.addFeature(feature);
        /* Should be set to false in order for circle to stay in the same size in the next tick tick, if there aren't new
          attacks in the same coordinates */
        currCircle.shouldDraw = false;
      }
    }
  }

  this.replayPausedMap = () => {
    for(var i=0; i<this.circles.length; ++i) {
      var currCircle = this.circles[i];
      if(currCircle.paused) { 
        var geom = new ol.geom.Circle(ol.proj.fromLonLat([currCircle.x, currCircle.y], "EPSG:4326"), currCircle.pausedRadius);
        var feature = new ol.Feature(geom);
        var styleTrans = new ol.style.Style({
          stroke: new ol.style.Stroke({
            color: 'transparent'
          })
        });
        feature.setStyle(styleTrans);
        feature.setId(++this.featureIdCounter);
        this.featureIdToCircle[feature.getId()] = currCircle;
        feature.country = currCircle.country;
        // Continuing animated from where it has stopped
        this.animatedCirclesSourceVec.addFeature(feature);
        // Removing the permanent circle that was put for pause
        if(currCircle.lastPermanentFeature != null) {
          this.permanentCirclesSourceVec.removeFeature(currCircle.lastPermanentFeature);
          currCircle.lastPermanentFeature = null;
        }
      }
    }

    var elapsedTime = $("#map_time").attr("T") *  this.totalPlayTime;
    if(this.lastDateIdxOfAttacksShown + 1 <= this.dataPerTick.length -1) {
      var nextDateIdxToPlay = this.lastDateIdxOfAttacksShown + 1;
      var timeToPlayNextDate = this.intervalBetweenTicks * nextDateIdxToPlay;
      if(timeToPlayNextDate > elapsedTime) { // Unless there's something wrong, this should evaluate to true
        this.nextDateTimerID = setTimeout(this.createAndDrawAttackCirclesForDate, timeToPlayNextDate - elapsedTime, nextDateIdxToPlay);
      }
    }
  }
  
  this.createAndDrawAttackCirclesForDate = (dateIdx) => {
    if(!this.played) {
      return;
    }

    if(dateIdx >= this.dataPerTick.length) {
      return;
    }

    if(dateIdx <= this.dataPerTick.length-2) {
      this.nextDateTimerID = setTimeout(this.createAndDrawAttackCirclesForDate, this.intervalBetweenTicks, dateIdx + 1);
    }

    this.lastDateIdxOfAttacksShown = dateIdx;

    var coordsForDate = this.dataPerTick[dateIdx].coords;
    for(var i=0; i<coordsForDate.length; ++i) {
      var foundMatchingCircle = false;
      for(var j=0; j<this.circles.length; ++j) {
        var currCircle = this.circles[j];
        if ((coordsForDate[i].longitude == currCircle.x) &&
            (coordsForDate[i].latitude == currCircle.y)) {
            currCircle.hits += coordsForDate[i].hits;
            currCircle.shouldDraw = true;
            foundMatchingCircle = true;
            break;
          }
      }
      if(!foundMatchingCircle) {
        var currCircle = { x: coordsForDate[i].longitude,
                          y: coordsForDate[i].latitude,
                          country: coordsForDate[i].country,
                          hits: coordsForDate[i].hits,
                          shouldDraw: true,
                          paused: false };
        this.circles.push(currCircle);
      } 
    }
    this.calculateCirclesRadius();
    this.drawAttackCircles();
  }
  
  this.calculateCirclesRadius = () => {
    for(var i=0; i<this.circles.length; ++i) {
      var currCircle = this.circles[i];
      currCircle.radius = 2 + Math.ceil((currCircle.hits / this.totalHitsForAllDates)*20);
    }
  }

  /**
   * This function is called when an animation should start for a circle.
   */
  this.flash = (feature) => {
    var start = new Date().getTime(); // Saving the time the animation started

    /**
     * This function produces the animation. It's a callback that on each call changes
     * the size of the circle
     * 
     * @param {object} event Object representing the animated circle
     */
    var animate = (event) => {

      var flashGeom = feature.getGeometry().clone();
      var matchingCircle = this.featureIdToCircle[feature.getId()];
      var vectorContext = event.vectorContext;
      var frameState = event.frameState;
      var elapsed = frameState.time - start;
      var totalAnimationDuration = 1000;

      var duration =  totalAnimationDuration;
      if(matchingCircle.paused) {
        // If the map play has already been paused before, the left duration is set accordingly
        duration = totalAnimationDuration - (matchingCircle.pausedRadius/matchingCircle.radius) * totalAnimationDuration;
      }
      var radius;
      if(elapsed >= duration) {
        duration = elapsed;
        radius = matchingCircle.radius;
      }
      else {
        var elapsedRatio = elapsed / duration;
        radius = ol.easing.easeOut(elapsedRatio) * matchingCircle.radius;
        if(matchingCircle.paused) {
          radius =  matchingCircle.pausedRadius + ol.easing.easeOut(elapsedRatio) * (matchingCircle.radius - matchingCircle.pausedRadius);
        }
      }

      var animatedCircleStyle = new ol.style.Style({
        stroke: new ol.style.Stroke({
          color: rgbColorToRgba(MAP_EVENTS_COLOR, '0.5'),
          width: 1
        }),
        fill: new ol.style.Fill({
          color: rgbColorToRgba(MAP_EVENTS_COLOR, '0.2')
        }),
      });

      if(this.pausing && (elapsed < duration)) {
        matchingCircle.paused = true;
        matchingCircle.pausedRadius = radius;

        flashGeom.setRadius(radius);
        var perm_feature = new ol.Feature(flashGeom);
        perm_feature.setStyle(animatedCircleStyle);
        perm_feature.setId(++this.featureIdCounter);
        if(matchingCircle.lastPermanentFeature != null) {
          this.permanentCirclesSourceVec.removeFeature(matchingCircle.lastPermanentFeature);
        }
        matchingCircle.lastPermanentFeature = perm_feature;
        perm_feature.country = matchingCircle.country;
        this.permanentCirclesSourceVec.addFeature(perm_feature);
        ol.Observable.unByKey(listenerKey);
        this.animatedCirclesSourceVec.removeFeature(feature);

        return;
      }
    
      flashGeom.setRadius(radius);
      vectorContext.setStyle(animatedCircleStyle);
      vectorContext.drawGeometry(flashGeom);
      if (elapsed >= duration) {
        matchingCircle.paused = false;
        if(matchingCircle.lastPermanentFeature != null) {
          this.permanentCirclesSourceVec.removeFeature(matchingCircle.lastPermanentFeature);
          matchingCircle.lastPermanentFeature = null;
        }
        var style_perm = new ol.style.Style({
          fill: new ol.style.Fill({
            color: rgbColorToRgba(MAP_EVENTS_COLOR, '0.2')
          }),
        });
        var perm_feature = new ol.Feature(flashGeom);

        perm_feature.setStyle(style_perm);
        perm_feature.country = matchingCircle.country;
        this.permanentCirclesSourceVec.addFeature(perm_feature);

        if(matchingCircle.lastPermanentFeature != null) {
          this.permanentCirclesSourceVec.removeFeature(matchingCircle.lastPermanentFeature);
        }
        matchingCircle.lastPermanentFeature = perm_feature;
        ol.Observable.unByKey(listenerKey);
        this.animatedCirclesSourceVec.removeFeature(feature);
        return;
      }
      // Tell OpenLayers to continue postcompose animation
      this.map.render();
    }
    // Sets animate() to be called (the animation is composed by animate())
    var listenerKey = this.map.on('postcompose', animate);
    // Saving the animate() callback (may be used in order to stop calling it in case of pause)
    this.animationListenerKeys.push(listenerKey);
  }

  /**
   * Disables the Malware Family section (it won't be shown in the report)
   */
  this.disableSection = () => {
    $('#map').parents('.panel').hide();
    this.disabled = true;
  }

  this.disableMap = () => {
    var mapHeight = parseInt($('#map-wrapper').css('height'));
    var sectionHeight = parseInt($('#malware_family .panel-body').css('height'));
    $('#map-wrapper').hide();
    $('#malware_family .panel-body').css('height', (sectionHeight - mapHeight) + 'px');
    $('#family-wrapper').css('height', '100%');
  }

  /**
   * Given the malware family desscription string, this function formats it
   * to fit the corresponding DOM object properly
   */
  this.setMalwareFamilyDescription = (description) => {
    const ellipsis = '...';
    const maxDescriptionLength = 350; // Up to 350 characters should fit in the description DOM object
    if(description.length > maxDescriptionLength) {
      // Since the description text is too long for the DOM object, it is cut and ellipsis is added in the end
      var lastSpaceIdx = description.substring(0, maxDescriptionLength - ellipsis.length).lastIndexOf(' ');
      if(lastSpaceIdx != -1) {
        description = description.substring(0, lastSpaceIdx);
        description = description.concat(ellipsis);
      }
      else {
        description = '';
      }
    }
    $('#family p').html(description); // Sets the text in the DOM object
  }

  function on_selection_change(selected_item) {
  }


  /**
   * Should be called from the live_services.js module in order to set the data of the Malware Family.
   *
   * NOTE: dataObj should specifically be the data object of the malware family and 
   *        NOT the similarities between the emulated file and the malware family.
   *        In order to set the similarities data, setSimilaritiesData() should be 
   *        called, with the relevant data object
   * 
   * @param {boolean} liveDataExists Indicates whether dataObj contains the expected data
   *			  (i.e. whether the live_services.js module succeeded in getting
   *			  updated Malware Family data).
   *			  If liveDataExists == false, there's attempt to read the data
   * 			  from a static json file of the report (json/malware_family.js)
   * @param {object}  dataObj Object containing data related to the malware family
   */
  this.setData = (liveDataExists, dataObj) => {
    var data;
    if(liveDataExists) {
      data = dataObj;
    }
    else {
      // When read from a static file, the malware family data is wrapped in an object with key "malware_family"
      data = getMalwareFamilyJSON();
      if(!('malware_family' in data)) {
        if(!this.similaritiesExist) {
          this.disableSection();
        }
        else {
          this.disableMap();
        }
        return;
      }
      data = data['malware_family'];
    }
    this.setDataInner(data);
  }

  /**
   * Should be called in order to set the data of the Malware Family.
   * NOTE: dataObj should specifically be the data object of the malware family and 
   *        not the similarities between the emulated file and the malware family.
   *        In order to set the similarities data, setSimilaritiesData() should be 
   *        called, with the relevant data object
   * 
   * @param {object}  dataObj Object containing data related to the malware family
   */
  this.setDataInner = (dataObj) => {
    this.resetData();

    if(!dataObj['malware_family_map_events'] || (Object.keys(dataObj['malware_family_map_events']).length == 0))
    { 
      if((!dataObj['malware_family_description'] || (dataObj['malware_family_description'].length == 0)) &&
          !this.similaritiesExist) {
          this.disableSection();
      }
      else {
        this.disableMap();
      }
    }
    if(dataObj['malware_family_description'])
      this.setMalwareFamilyDescription(dataObj['malware_family_description']);

    if(dataObj['malware_family_link'] && (dataObj['malware_family_link'].length > 0)) {
      $('#family-link').attr('href', dataObj['malware_family_link']);
    }
    else {
      $('#family-link').hide();
    }

    if('malware_family_map_events' in dataObj) {
      this.jsonToDisplayedDataPerTick(dataObj['malware_family_map_events']);

      if(this.dataPerTick.length == 0) {
        return;
      }
      this.totalPlayTime = (this.dataPerTick.length - 1) * this.intervalBetweenTicks + 3/24*this.intervalBetweenTicks;
      this.totalHitsForAllDates = this.calculateTotalHitsForAllDates(this.dataPerTick);
      this.buildGraph();
  
      setTimeout(this.playMapAndGraph, 2000); // Starts to play map + graph, after 2 seconds
    }
  }
  
  this.playMapAndGraph = () => {
    // Making sure that map isn't being played already
    if(this.played || this.pausing) {
      return;
    }
    this.animationListenerKeys = [];
    this.nextDateTimerID = -1;

    if($("#map_time").attr("T") > 0) {
      // Not playing from the beginning, starting from where paused
      this.played = true;    
      this.replayPausedMap();
    }
    else {
      // Playing from the beginning, thus map + graph objects are reset
      this.slider.attr("transform", "translate(0,0)");
      this.resetCircles();
      this.featureIdCounter = 0;
      /* Cleaning the layers of attack data from map, in order to be able
      to play it from the beginning */
      this.animatedCirclesSourceVec.clear();
      this.permanentCirclesSourceVec.clear();
      this.fixedPointsSourceVec.clear();
      this.played = true;    
      this.nextDateTimerID = setTimeout(this.createAndDrawAttackCirclesForDate, 0, 0);
    }
   
    var playTime = this.totalPlayTime;
    var elapsedTime = $("#map_time").attr("T") * this.totalPlayTime;
    if(elapsedTime > 0) {
      // Subtracting the time already played before from the time to play (Getting the remaining time)
      playTime -= elapsedTime;
    }
    this.slider.interrupt();
    d3.select("#map_time").interrupt();
    
    // Animating the movement of the bar's slider using transition
    this.slider.transition()
      .duration(playTime)
      .ease("linear")
      .attr("transform", "translate(" + this.xAxisLength + ",0)")
      .each('end', () => {
        this.playEndCallback();
      });
    // Starting transition of element used to calculate elapsed time of playing
    d3.select("#map_time")
      .transition()
      .duration(playTime)
      .ease("linear")
      .attr("T",1);
      // Change button icon to pause;
    $('#map_controls .btn-circle span').html('&#xe073;');
  }

  /**
   * Called when play reaches its end
   */
  this.playEndCallback = () => {
    /* Playing actually ends when the animations of the circles of last time tick  
      have finished - after animation has finished a permanent circle is added to 
      a different source vector and the circle from the animation vector is removed. 
      Thus if the animations source vector has no features, all animations have
      finished */
    if(this.animatedCirclesSourceVec.getFeatures().length == 0) {
      // Stopping and zeroing the playing timer
      d3.select("#map_time").interrupt().attr("T",0);
      // Change button icon to play
      $('#map_controls .btn-circle span').html('&#xe072;');
      this.played = false;
      
    }
    // Animations have not finished - thus calling function again after 300 ms
    else {
      setTimeout(this.playEndCallback, 300);
    } 
  }

  /**
   * Called when pause was clicked
   */
  this.pause = () => {
     // Making sure that map isn't paused already
    if(!this.played || this.pausing) {
      return;
    }
    if(this.nextDateTimerID != -1) {
      // Unsubscribing callback used for creating the map circles of the next date during play time
      clearTimeout(this.nextDateTimerID);
      this.nextDateTimerID = -1;
    }
    this.checkPauseFinished();
    // Stopping the movement of the bar's slider
    this.slider.interrupt(); 
    // Stopping timer update in order to calculate later the elapsed time till pause
    d3.select("#map_time").interrupt();
  }

  /**
   * After pause is click, this function is called, perhaps more than once
   * (as callback) in order to make sure pasue has finished (that all map circle animations
   * have stopped)
   */
  this.checkPauseFinished = () => {
    /* Checks if all animations have finished - after animation has finished
      a permanent circle is added to a different source vector and the circle 
      from the animation vector is removed. Thus if the animations source vector
      has no features, all animations have finished */
    if(this.animatedCirclesSourceVec.getFeatures().length == 0) {
      this.played = false;
      // Change play/pause button icon to play
      $('#map_controls .btn-circle span').html('&#xe072;');
      // Indicates that the pause process has finished
      this.pausing = false;
    }
    else {
      // This flag indicates that the map is during pause process
      this.pausing = true;
      // Animations have not finished - thus calling function again after 300 ms
      setTimeout(this.checkPauseFinished, 300);
    }
  }

  /**
   * Called when replay button is clicked
   */
  this.replayMapAndGraph = () => {
    // 
    var wasPlaying = this.played;
    // If the map was playing before clicking replay
    if(wasPlaying) {
      // Stopping all currently animated map circles
      for(var i=0; i<this.animationListenerKeys.length; ++i) {
        ol.Observable.unByKey(this.animationListenerKeys[i]);
      }
      this.animationListenerKeys = [];
      this.slider.interrupt();
      // Stopping timer change in order to calculate later the elapsed time
      d3.select("#map_time").interrupt();
      if(this.nextDateTimerID != -1) {
        // Unsubscribing callback used for creating the map circles of the next date during play time
        clearTimeout(this.nextDateTimerID);
        this.nextDateTimerID = -1;
      }
      // Chaning play/pause button icon to play
      $('#map_controls .btn-circle span').html('&#xe072;');
    }
    this.slider.attr("transform", "translate(0,0)");
    $("#map_time").attr("T",0);
    this.played = false;
    if(wasPlaying) {
      // Starts playing map + graph again
      this.playMapAndGraph();
    }
  }

  /**
   * Should be called in order to set the data of the similatrities between the emulated
   * file and the malware family.
   * NOTE: dataObj should specifically be the similarities between the emulated file and 
   *        the malware family and NOT data object of the malware family itself (which 
   *        includes the family's description and spread map).
   *        In order to set the malware family data, setData() should be 
   *        called, with the relevant data object
   * 
   * @param {object}  jsonData Object containing data of the similarities between
   *                            the emulated file and the malware family
   */
  this.setSimilaritiesData = (jsonData) => {
    // If there's no malware family name, the Malware Family section is disabled
    if(!jsonData.malware_family_name || jsonData.malware_family_name.length == 0) {
      this.disableSection();
      return;
    }
    this.primaryFamilyName = jsonData.malware_family_name;

    $('#family h1').prepend(this.primaryFamilyName);

    // Setting the similarities content under "Similarity Analysis"
    this.createSimilarIOCs(jsonData);
    this.createSimilarHashes(jsonData);
    this.createSimilarCodeBlocks(jsonData);

    // Adding the names of the families to the DNA double-helix
    var dnaData = [];
    var otherFamilies = jsonData['other_families'];
    if(otherFamilies && (otherFamilies.length > 0)) {
    	dnaData = otherFamilies.map(f => ({name: f.family_name, value: f.similarity_percentage}));
    }
    else {
      dnaData.push({name: this.primaryFamilyName, value: 100});
    }
    drawDNA("dna", dnaData, on_selection_change, 0);

    this.activateFirstSimilaritiesSection();
  }

  /**
   * Called from a function outside of this module.
   * The emulation events are needed in order to build the Similar Communication container.
   * 
   * @param {object}  eventsPerImage Object containining image events (the keys are image ids)
   */
  this.createSimilarCommunication = (eventsPerImage) => {
    var communicationEvents = new Set(); /* We use set in order not to repeat the same events
                                        (most of the events probably repeat in the different images)   */
    var values = Object.keys(eventsPerImage).map(function(e) {
      return eventsPerImage[e];
    })
    values.forEach(function(events) {
      for(var i=0; i<events.length; ++i) {
        var currEvent = events[i];
        if((currEvent.Type == 'SuspiciousActivityEvent') && (currEvent.ID == 'UrlRepID')) {
          var dest = currEvent.Dst.substring(currEvent.Dst.indexOf('(') + 1, currEvent.Dst.indexOf(')'));
          communicationEvents.add(dest);
        }
      }
    });
    // Only if suspicious network events found, the similar communication section will be shown
    if(communicationEvents.size > 0) {
        $('#similarities-body ul a[href$="#similar-communication"]').parent().show();
        this.similaritiesExist = true;
    }
    communicationEvents.forEach(function(event) {
      $('#similar-communication ul').append('<li>' + event + '</li>');
    });
    
    /* In case there is not other section with data, the similar communication
     section should be active */
    this.activateFirstSimilaritiesSection();
  }

  this.createSimilarCodeBlocks = (jsonData) => {
    function codeToHtml(codeLine, idx) {
      if(!codeLine) return "";
      return '<div>' + (idx+1) + '&nbsp;&nbsp;' + codeLine + '</div>';
    }

    var codeBlocks = jsonData['similar_code_blocks'];
    if(!Array.isArray(codeBlocks) || codeBlocks.length == 0) { 
      $('#similarities-body ul a[href$="#similar-code"]').parent().hide();
      return;
    }
    this.similaritiesExist = true;
    for(var i=0; i<codeBlocks.length; ++i) {
      if(i == 3) break; /* Allowing only 3 code blocks maximum, in order to to get to much
                            text in the code block similarities  section */
      var currBlock = codeBlocks[i].split("\n");
     $('<div class="code-block"> \
        <div class="code-block-title">Code block ' + (i+1) + ' of ' 
        + ((codeBlocks.length <= 3) ? codeBlocks.length : 3) +  '</div> \
        <div class="code-block-body"> ' + 
        currBlock.map(codeToHtml).join("") + '</div>\
        </div>').appendTo('#similar-code');
    }
  }

  this.createSimilarHashes = (jsonData) => {
    var hashes = jsonData['similar_hashes'];
    if(!Array.isArray(hashes) || (hashes.length == 0)) {
      $('#similarities-body ul a[href$="#similar-hashes"]').parent().hide();
      return;
    }
    this.similaritiesExist = true;
    for(var i=0; i<hashes.length; ++i) {
      var currHash = hashes[i];
      var linkToVT = 'https://www.virustotal.com/#/file/' + currHash +
          '/detection';
      $('#similar-hashes ul').append('<li><a href="' + linkToVT + '" target="_blank"><u>' + 
          currHash + '</u></a></li>');
    }
  }

  this.createSimilarIOCs = (jsonData) => {
    this.copySimilaritiesFromList(jsonData['similar_iocs'], $('#similar-iocs'));
  }

  this.copySimilaritiesFromList = (jsonList, div) => {
    if(!Array.isArray(jsonList) || (jsonList.length == 0)) {
      var divId = div.attr('id');
      $('#similarities-body ul a[href$="#' + divId + '"]').parent().hide();
      return;
    }
    this.similaritiesExist = true;
    for(var i=0; i<jsonList.length; ++i) {
      div.append('<li>' + jsonList[i] + '</li>');
    }
  } 

  this.activateFirstSimilaritiesSection = () => {
    $('#similarities-body ul li:visible').first().children().first().click();
  }

  this.disabled = false; // By default the section is active, unless disabled by disableSection()
  this.similaritiesExist = false; // By default. If similaries found it's set to true

  // Building the base map
  this.createMapLayers();
  
  // Reading family similarities data. It also includes the family name (of the primary family and the others)
  this.setSimilaritiesData(getMalwareFamilySimilaritiesJSON());
}

